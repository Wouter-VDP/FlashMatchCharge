////////////////////////////////////////////////////////////////////////
// Class:       PandoraAnalyzer
// Module Type: analyzer
// File:        PandoraAnalyzer_module.cc
//
// Generated at Thu Jun 23 00:24:52 2016 by Lorena Escudero Sanchez using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

// TODO
// - Put fidvol, electron_energy_threshold and proton_energy_threshold as fcl parameters
// - Use Geometry service for TPC size

#include <fstream>

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"


//uncomment the lines below as you use these objects

#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/RecoBase/Vertex.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/MCBase/MCShower.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "canvas/Persistency/Common/FindOneP.h"
#include "canvas/Utilities/InputTag.h"

#include "larpandora/LArPandoraInterface/LArPandoraHelper.h"

#include "TTree.h"
#include "TFile.h"
#include "TEfficiency.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "PandoraAnalysis/PandoraAnalysis.hh"

using namespace lar_pandora;

namespace geo { class Geometry; }

namespace test {
  class PandoraAnalyzer;
}


double distance(double a[3], double b[3]) {
  double d = 0;

  for (int i = 0; i < 3; i++) {
    d += pow((a[i]-b[i]),2);
  }

  return sqrt(d);
}

class test::PandoraAnalyzer : public art::EDAnalyzer {
public:
  explicit PandoraAnalyzer(fhicl::ParameterSet const & pset);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  virtual ~PandoraAnalyzer();

  // Plugins should not be copied or assigned.
  PandoraAnalyzer(PandoraAnalyzer const &) = delete;
  PandoraAnalyzer(PandoraAnalyzer &&) = delete;
  PandoraAnalyzer & operator = (PandoraAnalyzer const &) = delete;
  PandoraAnalyzer & operator = (PandoraAnalyzer &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void reconfigure(fhicl::ParameterSet const &pset) override;

private:

  test::PandoraAnalysis fMyAnalysisObj;
  TFile * myTFile;
  TTree * myTTree;
  TEfficiency * e_energy;
  bool m_printDebug;
  double m_fidvolXstart;
  double m_fidvolXend;

  double m_fidvolYstart;
  double m_fidvolYend;

  double m_fidvolZstart;
  double m_fidvolZend;

  double m_trackLength;

  bool is_fiducial(double x[3]) const;



};


test::PandoraAnalyzer::PandoraAnalyzer(fhicl::ParameterSet const & pset)
  :
  EDAnalyzer(pset)  // ,
 // More initializers here.
{

  //create output tree
  art::ServiceHandle<art::TFileService> tfs;
  myTFile = new TFile("PandoraAnalyzerOutput.root", "RECREATE");
  myTTree = tfs->make<TTree>("pandoratree","PandoraAnalysis Tree");

  e_energy = tfs->make<TEfficiency>("e_energy",";#nu_{e} energy [GeV];",30,0,3);


  //add branches


  this->reconfigure(pset);

}

test::PandoraAnalyzer::~PandoraAnalyzer()
{

  //store output tree
  myTFile->cd();
  myTTree->Write("pandoratree");
  myTFile->Close();

  std::cout << "End!" << std::endl;
}


bool test::PandoraAnalyzer::is_fiducial(double x[3]) const
{
  art::ServiceHandle<geo::Geometry> geo;
  double bnd[6] = {0.,2.*geo->DetHalfWidth(),-geo->DetHalfHeight(),geo->DetHalfHeight(),0.,geo->DetLength()};

  bool is_x = x[0] > (bnd[0]+m_fidvolXstart) && x[0] < (bnd[1]-m_fidvolXend);
  bool is_y = x[1] > (bnd[2]+m_fidvolYstart) && x[1] < (bnd[3]-m_fidvolYend);
  bool is_z = x[2] > (bnd[4]+m_fidvolZstart) && x[2] < (bnd[5]-m_fidvolZend);
  return is_x && is_y && is_z;
}




void test::PandoraAnalyzer::analyze(art::Event const & evt)
{

  //do the analysis
  art::InputTag pandoraNu_tag { "pandoraNu" };
  art::InputTag generator_tag { "generator" };

  int bkg_category = 0;
  // 1 cosmic
  // 2 nu_e
  // 3 nu_mu
  // 4 NC
  // 5 Dirt

  auto const& generator_handle = evt.getValidHandle< std::vector< simb::MCTruth > >( generator_tag );
  auto const& generator(*generator_handle);
  int ccnc = -1;

  std::vector<simb::MCParticle> nu_mcparticles;
  if (generator.size() > 0) {
    ccnc = generator[0].GetNeutrino().CCNC();
    double true_neutrino_vertex[3] = {generator[0].GetNeutrino().Nu().Vx(),generator[0].GetNeutrino().Nu().Vy(),generator[0].GetNeutrino().Nu().Vz()};
    if (!is_fiducial(true_neutrino_vertex)) {
      bkg_category = 5;
    }

    for (int i = 0; i < generator[0].NParticles(); i++) {
      if (generator[0].Origin() == 1) {
        nu_mcparticles.push_back(generator[0].GetParticle(i));

      }
    }
  } else {
    bkg_category = 1;
  }


  if (bkg_category != 1 && bkg_category != 5) {
    int protons = 0;
    int electrons = 0;
    int muons = 0;

    for (auto& mcparticle: nu_mcparticles) {
      if (mcparticle.Process() == "primary" and mcparticle.T() != 0 and mcparticle.StatusCode() == 1) {

        switch(mcparticle.PdgCode())
        {
          case (2212):
          protons++;
          break;

          case (11):
          electrons++;
          break;

          case (13):
          muons++;
          break;
        }

      }
    }


    try {
      auto const& pfparticle_handle = evt.getValidHandle< std::vector< recob::PFParticle > >( pandoraNu_tag );
      auto const& pfparticles(*pfparticle_handle);

      int most_z_ipf = 0;
      double most_z = -1;
      double longest_track_dir = 0;

      for (size_t ipf = 0; ipf < pfparticles.size(); ipf++) {

        bool is_neutrino = (abs(pfparticles[ipf].PdgCode()) == 12 || abs(pfparticles[ipf].PdgCode()) == 14) && pfparticles[ipf].IsPrimary();
        if (!is_neutrino) continue;


        int showers = 0;
        int tracks = 0;

        for (auto const& pfdaughter: pfparticles[ipf].Daughters()) {

          if (pfparticles[pfdaughter].PdgCode() == 11) {
            art::FindOneP< recob::Shower > shower_per_pfpart(pfparticle_handle, evt, pandoraNu_tag);
            auto const& shower_obj = shower_per_pfpart.at(pfdaughter);
            bool contained_shower = false;
            double start_point[3];
            double end_point[3];

            double shower_length = shower_obj->Length();
            for (int ix = 0; ix < 3; ix++) {
              start_point[ix] = shower_obj->ShowerStart()[ix];
              end_point[ix] = shower_obj->ShowerStart()[ix]+shower_length*shower_obj->Direction()[ix];
            }

            contained_shower = is_fiducial(start_point) && is_fiducial(end_point);

            if (contained_shower) showers++;

          }

          longest_track_dir = 0;
          double longest_track = 0;

          if (pfparticles[pfdaughter].PdgCode() == 13) {
            art::FindOneP< recob::Track > track_per_pfpart(pfparticle_handle, evt, pandoraNu_tag);
            auto const& track_obj = track_per_pfpart.at(pfdaughter);

            if (track_obj->Length() < m_trackLength) {
              tracks++;
              if (track_obj->Length() > longest_track) {
                longest_track = track_obj->Length();
                longest_track_dir = track_obj->StartDirection()[2];
              }
            }
          }

        } // end for pfparticle daughters

        if (tracks >= 1 && showers >= 1 && longest_track_dir > most_z) {
          most_z_ipf = ipf;
          most_z = longest_track_dir;
        }

      } // end for pfparticles
      std::cout << most_z << " " << most_z_ipf << std::endl;

    } catch (...) {
      std::cout << "NO RECO DATA PRODUCTS" << std::endl;
    }

    if (ccnc == 1) {
      bkg_category = 4;
    else if (protons != 0 && electrons != 0) {
      bkg_category = 2;
    } else if (protons != 0 && muons != 0) {
      bkg_category = 3;
    }
  } // end bkg_category != 1 if

  std::cout << bkg_category << std::endl;


} // end analyze function

//------------------------------------------------------------------------------------------------------------------------------------


void test::PandoraAnalyzer::reconfigure(fhicl::ParameterSet const & pset)
{

  //TODO: add an external fcl file to change configuration
  //add what you want to read, and default values of your labels etc. example:
  //  m_particleLabel = pset.get<std::string>("PFParticleModule","pandoraNu");

  m_printDebug = pset.get<bool>("PrintDebug",false);
  m_trackLength = pset.get<int>("trackLength",100);

  m_fidvolXstart = pset.get<double>("fidvolXstart",10);
  m_fidvolXend = pset.get<double>("fidvolXstart",10);

  m_fidvolYstart = pset.get<double>("fidvolYstart",20);
  m_fidvolYend = pset.get<double>("fidvolYend",20);

  m_fidvolZstart = pset.get<double>("fidvolZstart",10);
  m_fidvolZend = pset.get<double>("fidvolZend",50);
}

//---------------------------------------------------------------------------------------------------------------------------
//add other functions here

DEFINE_ART_MODULE(test::PandoraAnalyzer)
